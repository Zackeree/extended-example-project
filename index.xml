<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>YCP Radio Telescope Knowledge Base</title>
    <link>/example-project/</link>
    <description>Recent content on YCP Radio Telescope Knowledge Base</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	<atom:link href="/example-project/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>IntelliJ IDEA Ultimate Edition</title>
      <link>/example-project/environment/idea/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/example-project/environment/idea/</guid>
      <description>IntelliJ Idea Ultimate Edition IntelliJ offers free licenses to anyone with a .edu email meaning we can IntelliJ Idea Utilmate Edition completely free. All you need to do is make a JetBrains Account Here.
Once you have an account, you can download IntelliJ Idea Ultimate Edition. After you have cloned the GitHub Repository, you can open it up in IntelliJ and import it in. IntelliJ can recognize that this is a gradle project, and will let you import your gradle settings.</description>
    </item>
    
    <item>
      <title>NPM</title>
      <link>/example-project/environment/npm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/example-project/environment/npm/</guid>
      <description>NPM (Node Package Manager) is a Javascript package manager. If you&amp;rsquo;re running a modern Linux distro, you can likely install it through apt-get: $ sudo apt-get install npm. If you are using Windows, go here for the download.
Usage npm has lots of commands and features. The few you&amp;rsquo;ll use most often are listed below.
 npm install --save package-name - add package with name package-name to package.json as a runtime dependency.</description>
    </item>
    
    <item>
      <title>Common Git Tasks</title>
      <link>/example-project/workflows/git/common-git-tasks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/example-project/workflows/git/common-git-tasks/</guid>
      <description>Committing/Pushing Changes When committing changes, its important to avoid merge conflicts, and to avoid committing files that should not be added to version control; this includes IDE files/folders like *.iml files and the .idea directory, as well as any keyfiles like ~/.gradle/gradle.properties. The workflow to ensure this goes smoothly typically looks something like:
git status # show your local repo state git add . # or alternatively, git add path/to/file1.</description>
    </item>
    
    <item>
      <title>Kotlin Style Guide</title>
      <link>/example-project/styleguides/kotlin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/example-project/styleguides/kotlin/</guid>
      <description>General Notes Kotlin has no new operator; to create an instance of a class, you simply call the constructor as a normal function, e.g.
val userFactory = BaseUserFactory(userRepo)  Kotlin has a useful class definition keyword, the data keyword. Classes defined with the data keywork implicitly have useful helper methods like equals(), hashCode(), and toString() of the form (for example) &amp;quot;User(username=cspath1, email=cspath1@ycp.edu, password=pass1234)&amp;quot;, and copy() The copy() function provides the ability to very easily create a copy of a data class while optionally changing the value for any of the properties in the copy.</description>
    </item>
    
    <item>
      <title>Spring Data JPA</title>
      <link>/example-project/webapp-stack/backend/springdatajpa/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/example-project/webapp-stack/backend/springdatajpa/</guid>
      <description>Entities and Repositories Spring Data JPA (Java Persistence API), part of the Spring Data family, allows us to abstract away much of the SQL Layer by acting as a wrapper overtop of the SQL ORM layer. What Spring does is allows us to create Entity objects (indicated via the @Entity annotation, which model our database tables and allows us to perform CRUD operations on our MySQL database without actually ever needing to write a SQL statement.</description>
    </item>
    
  </channel>
</rss>